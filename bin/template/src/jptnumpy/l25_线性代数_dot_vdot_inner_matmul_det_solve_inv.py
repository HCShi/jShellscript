#!/usr/bin/python3
# coding: utf-8
# NumPy 包包含 numpy.linalg 模块, 提供线性代数所需的所有功能
# dot 两个数组的点积; vdot 两个向量的点积; inner 两个数组的内积; matmul 两个数组的矩阵积
# determinant 数组的行列式; solve 求解线性矩阵方程; inv 寻找矩阵的乘法逆矩阵
import numpy as np
##################################################################
# numpy.dot(); 返回两个数组的点积, 对于二维向量, 其等效于矩阵乘法
# 对于一维数组, 它是向量的内积; 对于 N 维数组, 它是 a 的最后一个轴上的和与 b 的倒数第二个轴的乘积
a = np.array([[1, 2], [3, 4]])
b = np.array([[11, 12], [13, 14]])
print(np.dot(a, b))  # [[37  40] [85  92]]
print(a.dot(b))  # 两种书写方式
# 要注意点积计算为: [[1*11+2*13, 1*12+2*14],[3*11+4*13, 3*12+4*14]]
print(np.dot([1, 2], [3, 4]))  # 11; 1*2 + 3*4
print(a * b)  # [[11 24] [39 56]]  # 直接相乘为叉积
##################################################################
# numpy.vdot(); 返回两个向量的点积, 如果第一个参数是复数, 那么它的共轭复数会用于计算; 如果是多维数组, 它会被展开
a = np.array([[1, 2], [3, 4]])
b = np.array([[11, 12], [13, 14]])
print(np.vdot(a, b))  # 130
# 注意: 1*11 + 2*12 + 3*13 + 4*14 = 130
##################################################################
# numpy.inner(); 返回一维数组的向量内积, 对于更高的维度, 它返回最后一个轴上的和的乘积
print(np.inner(np.array([1, 2, 3]), np.array([0, 1, 0])))  # 2
# 等价于 1*0 + 2*1 + 3*0 = 2
# 多维数组示例
a = np.array([[1, 2], [3, 4]]); print(a)  # [[1 2] [3 4]]
b = np.array([[11, 12], [13, 14]]); print(b)  # [[11 12] [13 14]]
print(np.inner(a, b))  # [[35 41] [81 95]]; 内积
# 上面的例子中, 内积计算如下:
# 1*11+2*12, 1*13+2*14
# 3*11+4*12, 3*13+4*14
##################################################################
# numpy.matmul(); 函数返回两个数组的矩阵乘积; 对于二维数组, 它就是矩阵乘法 (dot 点积)
# 虽然它返回二维数组的正常乘积, 但如果任一参数的维数大于2, 则将其视为存在于最后两个索引的矩阵的栈, 并进行相应广播
# 另一方面, 如果任一参数是一维数组, 则通过在其维度上附加 1 来将其提升为矩阵, 并在乘法之后被去除
a = [[1, 0], [0, 1]]; b = [[4, 1], [2, 2]]
print(np.matmul(a, b))  # [[4  1] [2  2]]
# 二维和一维运算
a = [[1, 0], [0, 1]]; b = [1, 2]
print(np.matmul(a, b))  # [1  2]
print(np.matmul(b, a))  # [1  2]
# 维度大于二的数组
a = np.arange(8).reshape(2, 2, 2)
b = np.arange(4).reshape(2, 2)
print(np.matmul(a, b))  # [[[2   3] [6   11]] [[10  19] [14  27]]]
##################################################################
# numpy.linalg.det() 函数计算输入矩阵的行列式, 行列式在线性代数中是非常有用的值, 它从方阵的对角元素计算,
# 对于 2×2 矩阵, 它是左上和右下元素的乘积与其他两个的乘积的差
# 对于矩阵 [[a, b], [c, d]], 行列式计算为 ad - bc, 较大的方阵被认为是 2×2 矩阵的组合
a = np.array([[1, 2], [3, 4]])
print(np.linalg.det(a))  # -2.0
b = np.array([[6, 1, 1], [4, -2, 5], [2, 8, 7]]); print(b)  # [[ 6 1 1] [ 4 -2 5] [ 2 8 7]]
print(np.linalg.det(b))  # -306.0
print(6*(-2*7 - 5*8) - 1*(4*7 - 5*2) + 1*(4*8 - -2*2))  # -306
##################################################################
# numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解; 考虑以下线性方程:
# x + y + z = 6
# 2y + 5z = -4
# 2x + 5y - z = 27
# 如果矩阵成为A、X和B, 方程变为: AX = B 或 X = A^(-1)B
A, B = np.array([[1, 1, 1], [0, 2, 5], [2, 5, -1]]), np.array([6, -4, 27])
print(np.linalg.solve(A, B))  # [5. 3. -2.], 这里得到的是行向量, 下面的是列向量
##################################################################
# numpy.linalg.inv() 计算矩阵的逆; (矩阵的逆乘以原始矩阵, 则得到单位矩阵)
x = np.array([[1, 2], [3, 4]]); print(x)  # [[1 2] [3 4]]
y = np.linalg.inv(x); print(y)  # [[-2.   1. ] [ 1.5 -0.5]]
print(np.dot(x, y))  # [[  1.00000000e+00   1.11022302e-16] [  0.00000000e+00   1.00000000e+00]]
# 现在让我们在示例中创建一个矩阵 A 的逆
a = np.array([[1, 1, 1], [0, 2, 5], [2, 5, -1]]); print(a)  # [[ 1 1 1] [ 0 2 5] [ 2 5 -1]]
ainv = np.linalg.inv(a); print(ainv)  # [[ 1.28571429 -0.28571429 -0.14285714] [-0.47619048 0.14285714 0.23809524] [ 0.19047619 0.14285714 -0.0952381 ]]
b = np.array([[6], [-4], [27]]); print(b)  # [[ 6] [-4] [27]]
x = np.linalg.solve(a, b); print(x)  # [[ 5.] [ 3.] [-2.]]; 计算: A^(-1)B
# 这就是线性方向 x = 5, y = 3, z = -2 的解; 结果也可以使用下列函数获取
x = np.dot(ainv, b); print(x)  # [[ 5.] [ 3.] [-2.]]
