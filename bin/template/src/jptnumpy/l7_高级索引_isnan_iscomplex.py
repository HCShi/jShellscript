#!/usr/bin/python3
# coding: utf-8
# 如果一个 ndarray 是非元组序列, 数据类型为整数或布尔值的 ndarray, 或者至少一个元素为序列对象的元组, 我们就能够用它来索引
# 高级索引始终返回数据的副本; 与此相反, 切片只提供了一个视图; 有两种类型的高级索引: 整数和布尔值
import numpy as np
##################################################################
# 整数索引
# 基于 N 维索引来获取数组中任意元素; 每个整数数组表示该维度的下标值; 当索引的元素个数就是目标 ndarray 的维度时, 会变得相当直接
# 以下示例获取了 ndarray 对象中每一行指定列的一个元素; 因此, 行索引包含所有行号, 列索引指定要选择的元素
x = np.array([[1, 2], [3, 4], [5, 6]])
y = x[[0, 1, 2], [0, 1, 0]]; print(y)  # [1  4  5]; 该结果包括数组中(0, 0), (1, 1)和(2, 0)位置处的元素
# 下面的示例获取了 4 X 3 数组中的每个角处的元素; 行索引是 [0, 0] 和 [3, 3], 而列索引是 [0, 2] 和 [0, 2]
x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])
rows = np.array([[0, 0], [3, 3]])
cols = np.array([[0, 2], [0, 2]])
print(x[rows, cols])  # [[ 0  2] [ 9 11]]  # 这个数组的每个角处的元素

# 以下示例使用 slice 作为列索引和高级索引; 当切片用于两者时, 结果是相同的; 但高级索引会导致复制, 并且可能有不同的内存布局
x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])
z = x[1:4, 1:3]; print(z)  # [[ 4  5] [ 7  8] [10 11]]
# 对列使用高级索引
y = x[1:4, [0, 2]]; print(y)  # [[ 3  5] [ 6  8] [9 11]]
##################################################################
# 布尔索引: 当结果对象是布尔运算(例如比较运算符)的结果时, 将使用此类型的高级索引
x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]); print(x[x > 5])  # [ 6  7  8  9 10 11]; 大于 5 的元素
a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5]); print(a[~np.isnan(a)])  # [1. 2. 3. 4. 5.]; 使用 ~(取补运算符) 过滤 NaN
a = np.array([1, 2+6j, 5, 3.5+5j]); print(a[np.iscomplex(a)])  # [2.0+6.j  3.5+5.j]; 数组中过滤掉非复数元素
