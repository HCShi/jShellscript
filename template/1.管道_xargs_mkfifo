##################################################################
## 1. 类管道命令
##################################################################
ls | wc -l  # 后一个命令在前一个的基础上运行
ls > test  # 重定向, 写入
find -name *.py | xargs grep asdf  # 作为参数, 找 py 结尾的文件中的字符串
findname "*.db" | xargs rm  # 删除子文件的指定文件
findname "*sqlmap*" | xargs -I {} cp {} ~/del  # 将 xargs 的结果作为第一个参数, 第一个 {} 是声明占位符
echo `python -c "print 'a'*24"`  # `` 将命令执行结果不变的返回  # aaaaaaaaaaaaaaaaaaaaaaaa

##################################################################
## 错误重定向
##################################################################
# 1）默认地, 标准的输入为键盘, 但是也可以来自文件或管道（pipe |）。
# 2）默认地, 标准的输出为终端（terminal), 但是也可以重定向到文件, 管道或后引号（backquotes `）。
# 3) 默认地, 标准的错误输出到终端, 但是也可以重定向到文件。
# 4）标准的输入, 输出和错误输出分别表示为STDIN,STDOUT,STDERR, 也可以用0, 1, 2来表示。
# 5）其实除了以上常用的3中文件描述符, 还有3~9也可以作为文件描述符。3~9你可以认为是执行某个地方的文件描述符, 常被用来作为临时的中间描述符。

ls Destop Desktop 2>tmp           # 会显示正确的在终端, 错误的在 tmp
ls dektop Desktop 2>&1            # 错误重定向到标准输出, 错误和标准输出, & 和 > 之间不能有空格
ls dektop Desktop 3>&2 2>&1 1>&3  # 标准输出和错误输出的交换, 没什么卵用
ls dektop Desktop 2>&1 1>&2       # 不能实现标准输出和错误输出的交换。因为shell从左到右执行命令, 当执行完2>&1后, 错误输出已经和标准输出一样的, 再执行1>&2也没有意义

ls dektop Desktop 2>&1 >tmp  # 错误输出到终端, 标准输出被重定向到文件file
ls dektop Desktop >tmp 2>&1  # 标准输出被重定向到文件file, 然后错误输出也重定向到和标准输出一样, 所以也错误输出到文件file
# File descriptor 1 is the standard output (stdout).
# File descriptor 2 is the standard error (stderr).
# Here is one way to remember this construct (although it is not entirely accurate):
# at first, 2>1 may look like a good way to redirect stderr to stdout.
# However, it will actually be interpreted as "redirect stderr to a file named 1".
# & indicates that what follows is a file descriptor and not a filename. So the construct becomes: 2>&1.

##################################################################
## 2. mkfifo
##################################################################
mkfifo pipe1  # 创建管道
ls -l pipe1  # prw-rw-r-- 1 coder352 coder352 0 Nov 17 20:31 pipe1, p 表示是管道, 大小为 0, 且一直为 0, 不占用本地磁盘
# 开启两个终端
ls -l > pipe1
cat < pipe1  # 两个命令的顺序可以反
# cat Usage: cat [OPTION]... [FILE]..., 默认是读文件, 但是 pipe1 就相当于文件
cat tmp
cat < tmp  # tmp 为普通文件, 这两行效果相同
