#!/bin/bash
##################################################################
# 1. 用 ssh 做正向连接
# 啥叫正向连接？就是 client 连上 server, 然后把 server 能访问的机器地址和端口(当然也包括 server 自己)镜像到 client 的端口上
ssh -L [客户端 IP 或省略]:[客户端端口]:[服务器侧能访问的 IP]:[服务器侧能访问的 IP 的端口] [登陆服务器的用户名@服务器 IP] -p [服务器 ssh 服务端口(默认22)]
# 其中, 客户端 IP 可以省略, 省略的话就是 127.0.0.1 了, 也就是说只能在客户端本地访问, 服务器 IP 都可以用域名来代替
# 举例说明:
# 你的 IP 是 192.168.1.2, 你可以 ssh 到某台服务器 8.8.8.8, 8.8.8.8 可以访问 8.8.4.4, 你内网里还有一台机器可以访问你
# 如果你想让内网里的另外一台电脑访问 8.8.4.4 的 80 端口的 http 服务, 那么可以执行:
ssh -L 192.168.1.2:8080:8.8.4.4:80 test@8.8.8.8
# 也就是说, ssh 到 8.8.8.8 上, 然后让 8.8.8.8 把 8.8.4.4 的 80 端口映射到本地的 8080 端口上, 而且和本地 192.168.1.2 这个 IP 绑定
# 内网里的另外一台机器可以通过浏览器中输入 http://192.168.1.2:8080 查看 8.8.4.4 的网页
# 当然, 如果是其他服务, 比如 ftp、ssh、远程桌面也是可以的; 不过, VPN 貌似是不行的, 可能是因为 GRE 协议无法通过
##################################################################
## 2. 用 ssh 做反向连接
# 啥叫反向连接？就是 client 连上 server, 然后把 client 能访问的机器地址和端口(也包括 client 自己)镜像到 server 的端口上
# 反向连接用得可能更多一些; 比如你的客户端在内网, 在外网是无法直接访问到的, 这时用反向连接打通一条隧道, 就可以从外网通过这条隧道进来了
ssh -R [服务器 IP 或省略]:[服务器端口]:[客户端侧能访问的 IP]:[客户端侧能访问的 IP 的端口] [登陆服务器的用户名@服务器 IP] -p [服务器 ssh 服务端口(默认22)]
# 其中, 服务器 IP 如果省略, 则默认为 127.0.0.1, 只有服务器自身可以访问;
# 指定服务器外网 IP 的话, 任何人都可以通过[服务器 IP:端口]来访问服务; 当然, 这个时候服务器本机也要输入外网 IP:端口来访问。
# 举例说明:
# 你的 IP 是 192.168.1.2, 你可以 ssh 到外网某台服务器 8.8.8.8, 你内网里有一台机器 192.168.1.3
# 如果你想让外网所有的能访问 8.8.8.8 的 IP 都能访问 192.168.1.3 的 http 服务, 那么可以执行:
ssh -R 8.8.8.8:8080:192.168.1.3:80 test@8.8.8.8
# 也就是说, ssh 到 8.8.8.8 上, 然后把本地局域网内 192.168.1.3 的 80 端口映射到 8.8.8.8 的 8080 端口上
# 这样外网任何一台可以访问 8.8.8.8 的机器都可以通过 8080 端口访问到内网 192.168.1.3 机器的 80 端口了
##################################################################
## 3. 用 ssh 做 socks 代理
# 假设你内网里某台机器可以上网, 但是你不能上网, 如果你有 ssh 到那台机器的权限, 那么就可以利用 ssh 方式建立一个代理 socks5, 通过代理来上网
ssh -D [本地IP或省略]:[本地端口] [登陆服务器的用户名@服务器 IP] -p [服务器 ssh 服务端口(默认22)]
